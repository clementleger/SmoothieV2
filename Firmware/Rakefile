require 'rake'
require 'pathname'
require 'fileutils'

verbose(ENV['verbose'] == '1')
TESTING = ENV['testing'].nil? ? false : ENV['testing'] == '1'

Target = Struct.new(:name, :defines)
supported_targets = [
  Target.new(
    'Minialpha',
    ['-DUSE_UART0', '-DUART0_PINSET=2', '-DNOETHERNET']
  ),
  Target.new(
    'Primealpha',
    ['-DUSE_UART0', '-DUART0_PINSET=15']
  ),
  Target.new(
    'Bambino',
    ['-DUSE_UART0', '-DUART0_PINSET=6']
  )
];

PROG = 'smoothiev2'
if ENV['target'].nil?
  TARGET = 'Bambino'
else
  TARGET = ENV['target']
end

target_struct = nil
supported_targets.each do |target|
  if target.name == TARGET
    target_struct = target
    break
  end
end

if target_struct.nil?
  puts "ERROR: Must specify target=[#{supported_targets.map{|t| t.name}.join(' ,')}]"
  exit 0
end

target_defines = target_struct.defines

puts "Target is #{TARGET}"

DEBUG = ENV['debug'] == '1'
DEBUGLIB = ENV['debuglib'] == '1'

$using_cpp= false

def pop_path(path)
  Pathname(path).each_filename.to_a[1..-1]
end

def obj2src(fn, e)
  File.absolute_path(File.join(pop_path(File.dirname(fn)), File.basename(fn).ext(e)))
end

# Makefile .d file loader to be used with the import file loader.
# this emulates the -include $(DEPFILES) in a Makefile for the generated .d files
class DfileLoader
  include Rake::DSL

  SPACE_MARK = "\0"

  # Load the makefile dependencies in +fn+.
  def load(fn)
    return if ! File.exists?(fn)
    lines = File.read fn
    lines.gsub!(/\\ /, SPACE_MARK)
    lines.gsub!(/#[^\n]*\n/m, "")
    lines.gsub!(/\\\n/, ' ')
    lines.each_line do |line|
      process_line(line)
    end
  end

  private

  # Process one logical line of makefile data.
  def process_line(line)
    file_tasks, args = line.split(':', 2)
    return if args.nil?
    dependents = args.split.map { |d| respace(d) }
    file_tasks.scan(/\S+/) do |file_task|
      file_task = respace(file_task)
      file file_task => dependents
    end
  end

  def respace(str)
    str.tr SPACE_MARK, ' '
  end
end

# Install the handler
Rake.application.add_loader('d', DfileLoader.new)

#TOOLSDIR = '/home/morris/work/reprap/Smoothie/gcc-arm-none-eabi/bin'
TOOLSDIR = ENV['ARMTOOLS'].nil? ? '/usr/bin' :  ENV['ARMTOOLS']
TOOLSBIN = "#{TOOLSDIR}/arm-none-eabi-"
LIBSDIR = "#{TOOLSDIR}/../lib"
CC = "#{TOOLSBIN}gcc"
CCPP = "#{TOOLSBIN}g++"
LD = "#{TOOLSBIN}ld"
LDCPP = "#{TOOLSBIN}c++"
OBJCOPY = "#{TOOLSBIN}objcopy"
OBJDUMP = "#{TOOLSBIN}objdump"
SIZE = "#{TOOLSBIN}size"
AR = "#{TOOLSBIN}ar"
ARFLAGS = 'ur'

current_version= `#{CC} -dumpversion`.chomp
puts "Current GCC version is #{current_version}"
ARMVERSION = ENV['ARMVERSION'].nil? ? current_version :  ENV['ARMVERSION']


# include a defaults file if present
load 'rakefile.defaults' if File.exists?('rakefile.defaults')

# Set build type
#BUILDTYPE= ENV['BUILDTYPE'] || 'Checked' unless defined? BUILDTYPE
#puts "#{BUILDTYPE} build"

# add lpcopen HAL files
hal_src = FileList['Hal/**/*.{c,cpp,s}']
#hal_src.exclude(/Adc/) # TODO

# RTOS
rtos_src = FileList['RTOS/**/*.{c,cpp,s}']

if TESTING
  # Unity tests
  src = FileList['Unity/src/*.c', 'src/**/*.{c,cpp,s}']
  src.exclude(/(src\/main.cpp)/) # we don't want the Firmware main.cpp
  src.exclude(/(src\/modules)/) # TODO these are not needed yet
  if ENV['test'].nil?
    # all tests
    src += FileList['TestUnits/TEST_*.cpp']
    src.exclude("TestUnits/TEST_diskio.cpp") # we do not want to do this as it wipes out the sdcard
    if ENV['exclude']
      ENV['exclude'].split(',').map { |i| "TestUnits/TEST_#{i}.cpp" }.each do |e|
        src.exclude(e)
      end
    end

  else
    # just named tests
    tests= ENV['test'].split(',')
    tests.each do |t|
      src += FileList["TestUnits/TEST_#{t}.cpp"]
    end
  end
  src += FileList['TestUnits/main.cpp']

  puts "Building Test Cases debug: #{DEBUG}"

else
  src = FileList['src/**/*.{c,cpp,s}'] #, 'staging/**/*.cpp' ]
  #src.exclude(/\/arm_solutions\/*/) # we don't want to look at these yet
  src.exclude(/max31855/) # TODO these are not ready yet
  puts "Building Firmware debug: #{DEBUG}"
end

# All sources
SRCS = hal_src + rtos_src + src

# Library sources
HAL_SRCS = hal_src + rtos_src

$using_cpp= SRCS.find { |i| File.extname(i) == ".cpp" }.nil? ? false : true

OBJDIR = "#{PROG}_#{TARGET}"
OBJ = src.collect { |fn| File.join(OBJDIR, File.dirname(fn), File.basename(fn).ext('o')) }
HAL_OBJ = HAL_SRCS.collect { |fn| File.join(OBJDIR, File.dirname(fn), File.basename(fn).ext('o')) }
OBJS = HAL_OBJ + OBJ

# list of header dependency files generated by compiler
DEPFILES = OBJS.collect { |fn| File.join(File.dirname(fn), File.basename(fn).ext('d')) }

# create destination directories
SRCS.each do |s|
  d= File.join(OBJDIR, File.dirname(s))
  FileUtils.mkdir_p(d) unless Dir.exists?(d)
end

include_dirs = ["./Hal/lpc_board_bambino/inc", "./Hal/lpc_chip_43xx/inc", "./Hal/lpc_chip_43xx/inc/config_43xx",
                "./Hal/lpc_chip_43xx/inc/usbd_rom", "./Hal/inc",
                "./RTOS/include",  "./Hal/sdmmc/inc", "./Hal/sdmmc/fatfs", "./Hal/usb_cdc/inc"] +
               [Dir.glob(['./src/**/'])].flatten # ,'./staging/**/'
sys_include_dirs = []

# [Dir.glob([PROG + '/**/Inc/**', './mri/**/'])].flatten

INCLUDE = (include_dirs).collect { |d| "-I#{d}" }.join(" ") # + " " + (sys_include_dirs).collect { |d| "-isystem #{d}" }.join(" ")

defines = %w(-D__USE_LPCOPEN -DCORE_M4 -D__CODE_RED -D__NEWLIB__ -DCPP_USE_HEAP -D__LPC43XX__ -D__MULTICORE_NONE)
if DEBUG
  defines << "-DDEBUG"
end

# Target specified #defines
defines << "-DBUILD_TARGET=\\\"#{TARGET}\\\" -D#{TARGET}"
if TARGET == 'Bambino'
defines << '-DSTRING_CONFIG_H=\"string-config-bambino.h\"'
elsif TARGET == 'Minialpha'
defines << '-DSTRING_CONFIG_H=\"string-config-minialpha.h\"'
elsif TARGET == 'Primealpha'
defines << '-DSTRING_CONFIG_H=\"string-config-minialpha.h\"'
else
  raise("Error unhandled target")
end

defines += target_defines

DEFINES= defines.join(' ')

DEPFLAGS = '-MMD '
CSTD = '-std=c99'
FFLAGS = ' -fmessage-length=0 -fno-builtin-printf -fno-builtin-isnan -ffast-math -ffunction-sections -fdata-sections '
CFLAGS = FFLAGS + DEPFLAGS + " -Wall -Wshadow -Wundef  -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16  " + (DEBUG ? "-O0 -g3 " : "-O2 -g")
CPPFLAGS = CFLAGS + ' -Wno-psabi -fno-exceptions -fno-rtti -fno-common -std=gnu++11'

# Linker script to be used.
LSCRIPT = TARGET == 'LPC4337' ? "./v2pro4337.ld"  : "./test_cpp_Debug.ld" # "./spificonfig.ld"

LOPTIONS = ['-Xlinker --gc-sections', '-Xlinker -print-memory-usage', '-Xlinker', '--wrap=malloc', '-Xlinker', '--wrap=_malloc_r',
            '-mcpu=cortex-m4', '-mfpu=fpv4-sp-d16', '-mfloat-abi=hard', '-mthumb']

LDFLAGS = "  -Xlinker -Map=#{OBJDIR}/#{PROG}.map -T#{LSCRIPT} " + LOPTIONS.join(" ")

# tasks
# desc "Upload via stlink"
# task :upload do
#   sh "./flashit #{OBJDIR}/#{PROG}.bin"
# end

desc "Upload via openocd"
task :upload do
  sh "./flashit.openocd #{OBJDIR}/#{PROG}.elf"
end

desc "Upload via dfu"
task :dfu do
  sh "/usr/bin/dfu-util -v -R -d 0483:df11 -a 0 --dfuse-address 0x08000000 -D #{OBJDIR}/#{PROG}.bin"
end

# generate the header dependencies if they exist
import(*DEPFILES)

task :clean do
  FileUtils.rm_rf(OBJDIR)
end

task :cleansrc do
  FileUtils.rm_rf("#{OBJDIR}/src")
  FileUtils.rm_rf("#{OBJDIR}/TestUnits")
end

task :cleantests do
  FileUtils.rm_rf("#{OBJDIR}/TestUnits")
end

task :default => [:build] #, :size]

task :build => ["#{OBJDIR}/#{PROG}.bin"]

task :size do
  sh "#{SIZE} #{OBJDIR}/#{PROG}.elf"
end

task :disasm do
  sh "#{OBJDUMP} -d -f -M reg-names-std --demangle #{OBJDIR}/#{PROG}.elf > #{OBJDIR}/#{PROG}.disasm"
end

task :version do
  v1= `git symbolic-ref HEAD 2> /dev/null`
  v2= `git log --pretty=format:%h -1`
  $version = ' -D__GITVERSIONSTRING__=\"' + "#{v1[11..-1].chomp}-#{v2}".chomp + '\"'
end

file "#{OBJDIR}/#{PROG}.bin" => ["#{OBJDIR}/#{PROG}.elf"] do |t|
  puts "Creating #{t.name}"
  sh "#{OBJCOPY} -O binary #{OBJDIR}/#{PROG}.elf #{OBJDIR}/#{PROG}.bin"
end

file "#{OBJDIR}/#{PROG}.elf" => ["#{OBJDIR}/libhal.a"] + OBJ do |t|
  puts "Linking #{t.name}"
  sh "#{$using_cpp ? LDCPP : LD} #{OBJ} -L#{OBJDIR} -lhal #{LDFLAGS} -o #{t.name}"
end

file "#{OBJDIR}/libhal.a" => HAL_OBJ do |t|
  puts "Creating #{t.name}"
  sh "#{AR} #{ARFLAGS} #{t.name} #{HAL_OBJ}"
end

# special case to always build the version
file "#{OBJDIR}/src/version.o" => [:version, 'src/version.cpp'] do |t|
  puts "Compiling src/version.cpp"
  sh "#{CCPP} #{CPPFLAGS} #{INCLUDE} #{DEFINES} #{$version} -c -o #{t.name} src/version.cpp"
end

#arm-none-eabi-objcopy -R .stack -O ihex ../LPC1768/main.elf ../LPC1768/main.hex
#arm-none-eabi-objdump -d -f -M reg-names-std --demangle ../LPC1768/main.elf >../LPC1768/main.disasm

rule '.o' => lambda{ |objfile| obj2src(objfile, 'cpp') } do |t|
  puts "Compiling #{t.source}"
  sh "#{CCPP} #{CPPFLAGS} #{INCLUDE} #{DEFINES} #{$version} -c -o #{t.name} #{t.source}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 'c') } do |t|
  puts "Compiling #{t.source}"
  sh "#{CC} #{CFLAGS} #{CSTD} #{INCLUDE} #{DEFINES} #{$version} -c -o #{t.name} #{t.source}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 's') } do |t|
  puts "Assembling #{t.source}"
  sh "#{CC} -c -mthumb -mcpu=cortex-m4 -mthumb-interwork -mlittle-endian -mfloat-abi=hard -mfpu=fpv4-sp-d16 -g -Wa,--no-warn -x assembler-with-cpp #{INCLUDE} -o #{t.name} #{t.source}"
end
